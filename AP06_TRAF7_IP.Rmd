---
title: "TRAF7 IP"
author: "Alex Panov"
date: "2025-01-13"
output: 
  html_document:
    toc: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## MSstats

```{r}
## Data directly from Kari, PD TMT output
#### Load required pacakges, MSstats ####
list.of.packages <- c("MSstats", "MSstatsTMT", "ggplot2", "plotly")
## installing instead in dockerfile specific versions
lapply(list.of.packages, library, character.only = TRUE)

#### Read in data from PDP ####
## Data table to be passed from PDP
## PDP SOURCE
df_raw_from_PDP <- read.csv("2024_12_16_TRAF7_IP_TMT18_FINAL_all_columns_PSMs.txt", header = T, sep = "\t", na.strings = c("", "NA", "NaN", "NULL", "Null", "null", "na"))
## Change name of "File.ID" to "Spectrum.File"
colnames(df_raw_from_PDP)[which(colnames(df_raw_from_PDP)=="File.ID")] <- "Spectrum.File"
## Assign a character that dictates where the sourced data is from, which dictates which converter to use. Options are "Spectronaut", "PD"
## PDP SOURCE
char_PDP_df_source <- "PD"

#### Filtering and X to MSstats Format Conversion, Annotation file ####
if (char_PDP_df_source == "PD") {
  ## Building df_annot manually
  ## Building the annotation file, df_annot, from PDP output "pools_export" file.
  # df_pools <- read.csv("dummy.tsv", header = T, sep = "\t", na.strings = c("", "NA", "NaN", "NULL", "Null", "null", "na"))
  # ## This is annotation df for TMT experiments 
  # ## Create the start of a df_annot df to fill
  # df_annot <- data.frame(
  #   ## sample_channel == Channel
  #   Channel = df_pools$sample_channel,
  #   ## treatment/drug == Condition, needs to be sorted out below
  #   Condition = rep(NA, length (df_pools$sample_channel)),
  #   ## BioReplicate == df$num <- ave(df$val, df$cat, FUN = seq_along) from Condition
  #   BioReplicate = rep(NA, length (df_pools$sample_channel)),
  #   ## Number of technical replicates. This will be accommodated in the future.
  #   TechRepMixture = rep(1, length(df_pools$sample_channel)),
  #   ## Fraction == matches number of Spectrum.File
  #   Fraction = rep(NA, length (df_pools$sample_channel)),
  #   ## Mixture, likely is 1. This would be multiple TMT mixtures. Another case for future.
  #   Mixture = rep(1, length (df_pools$sample_channel)),
  #   ## Run will be matched to Spectrum.File
  #   Run = rep(NA, length (df_pools$sample_channel))
  # )
  # ## Condition. For now, we can handle by drug/treatment columns
  # ## if there is a value in treatment, but not in drugs, use treatment column
  # df_annot$Condition <- ifelse(!is.na(df_pools$treatment) & is.na(df_pools$drug), df_pools$treatment, NA)
  # ## if there is a value in drugs, but not treatment, use drugs
  # df_annot$Condition <- ifelse(is.na(df_pools$treatment) & !is.na(df_pools$drug), df_pools$drug, df_annot$Condition)
  # ## all remaining conditions should concatenate
  # df_annot$Condition <- ifelse(is.na(df_annot$Condition), paste0(df_pools$treatment, ",",df_pools$drug), df_annot$Condition)
  # 
  # ## BioReplicate. We are assigning automatically based on "Condition", or "treatment" and "drug" from df_pools, but this can change if PDP has replicates entry.
  # df_annot$BioReplicate <- ave(df_annot$Channel, df_annot$Condition, FUN = seq_along)
  # ## repeat this the number of times * fractions/Spectrum.File
  # df_annot <- do.call("rbind", replicate(length(unique(df_raw_from_PDP$Spectrum.File)), df_annot, simplify = FALSE))
  # ## Fill in fraction number
  # df_annot$Fraction <- rep(c(1:length(unique(df_raw_from_PDP$Spectrum.File))), each = length(unique(df_annot$Channel)))
  # ## Add Spectrum.File for each fraction, in order
  # vec_spectrum_files <- unique(df_raw_from_PDP$Spectrum.File)
  # vec_spectrum_files <- vec_spectrum_files[order(nchar(vec_spectrum_files), vec_spectrum_files)]
  # df_annot$Run <- rep(vec_spectrum_files, each = length(unique(df_annot$Channel)))
  # ## save memory
  # df_annot_precursor <- NULL
  df_annot <- read.csv("PD_annot_manual.csv", header = T, sep = ",")
  df_annot <- do.call("rbind", replicate(length(unique(df_raw_from_PDP$Spectrum.File)), df_annot, simplify = FALSE))
  df_annot$TechRepMixture <- 1
  df_annot$Fraction <- rep(c(1:length(unique(df_raw_from_PDP$Spectrum.File))), each = length(unique(df_annot$Channel)))
  vec_spectrum_files <- unique(df_raw_from_PDP$Spectrum.File)
  vec_spectrum_files <- vec_spectrum_files[order(nchar(vec_spectrum_files), vec_spectrum_files)]
  df_annot$Run <- rep(vec_spectrum_files, each = length(unique(df_annot$Channel)))
  df_annot$Condition <- gsub("-.*$", "", df_annot$Condition)
  
  ## Run the MSstats converter. "Master.Protein.Accessions" is used for "ProteinName". "Sequence" and "Modifications" are used for "PeptideSequence". "Charge"
  list_quant <- MSstatsTMT::PDtoMSstatsTMTFormat(input = df_raw_from_PDP, 
                                                 annotation = df_annot, 
                                                 use_log_file = FALSE)
  ## save memory
  df_raw_from_PDP <- NULL

  ## dataProcess step with the output from the converter
  list_MSstats_processed <- MSstatsTMT::proteinSummarization(list_quant,
                                                       method = "msstats",
                                                       global_norm = TRUE,
                                                       MBimpute = FALSE, 
                                                       use_log_file = FALSE)
  ## save memory, compost
  list_quant <- NULL
  ## need to hold onto the entire list_MSstats_processed for the groupComparison step later
  
  ## some PD TMT plots. Might be useful integration eventually.
  dataProcessPlotsTMT(data = list_MSstats_processed, type = "QCplot", which.Protein = "allonly", width = 21, height = 7)
  ## This is nice for peptide level analysis!
  dataProcessPlotsTMT(data = list_MSstats_processed, type = "ProfilePlot", which.Protein = 1, width = 21, height = 7)
}

if(char_PDP_df_source=="PD") {
  ## make the controls, aka denominator
  ## PDP SOURCE
  vec_control_conditions <- c("Control", "TRAF7", "TRAF7_supp")
  ## create a list to collapse at end of building, one matrix for each control condition
  ## each element of this list will become a matrix, which we will rbind together at end
  list_mat_comparison_msstats <- vector("list", length= length(vec_control_conditions))
  ## make the experimental conditions. These have to match what PDP assigns as vec_control_conditions, have to match what is in the dataset. For Spectronaut, this is R.Condition column. 
  vec_experimental_conditions <- levels(list_MSstats_processed$ProteinLevelData$Condition)[!(levels(list_MSstats_processed$ProteinLevelData$Condition) %in% vec_control_conditions)]
  ## how to automate this matrix, hmm
  
  ## First create matrices that are length(vec_experimental_conditions) rows long with rownames == vec_experimental_conditions and colnames == all.
  for (i in 1:length(list_mat_comparison_msstats)) {
    ## for now, the rownames do not contain the name of the control condition. We will replace later after grepl step. 
    list_mat_comparison_msstats_names01 <- list(mat_comparison_rows = paste0(vec_experimental_conditions),
                                                mat_comparison_cols = levels(list_MSstats_processed$ProteinLevelData$Condition))
    list_mat_comparison_msstats[[i]] <- matrix(ncol = length(levels(list_MSstats_processed$ProteinLevelData$Condition)),
                                               nrow = length(vec_experimental_conditions),
                                               dimnames = list_mat_comparison_msstats_names01)
  }
  
  ## This is the major matrix creation step
  for (j in 1:length(list_mat_comparison_msstats)) {
    for (i in 1:length(vec_experimental_conditions)) {
      a <- paste0("^", vec_experimental_conditions[i], "$")
      b <- list_mat_comparison_msstats[[j]][i,]
      list_mat_comparison_msstats[[j]][i,] <- as.integer(grepl(a, names(b)))
    }
  }
  
  ## Now that we have that, we can assign the controls a value of -1
  for (i in 1:length(vec_control_conditions)) {
    list_mat_comparison_msstats[[i]][,grep(paste0("^", vec_control_conditions[i], "$"), colnames(list_mat_comparison_msstats[[i]]))] <- -1
  }
  
  ## last step is to add the control to the rownames
  for (i in 1:length(list_mat_comparison_msstats)) {
    list_mat_comparison_msstats_names02 <- paste0(vec_experimental_conditions, "-", vec_control_conditions[i])
    rownames(list_mat_comparison_msstats[[i]]) <-  list_mat_comparison_msstats_names02
    
  }
  
  ## Collapse into comparison matrix
  mat_comparison_msstats <- do.call(rbind, list_mat_comparison_msstats)
  ## BOOM
}

#### Run groupComparison, the stats portion, of MSstats ####
## Run the differential analysis using MSstats
list_DA_msstats <- MSstatsTMT::groupComparisonTMT(contrast.matrix = mat_comparison_msstats, data = list_MSstats_processed)

if(!file.exists("./data_images/24_01_13.RData")) {
  save.image("./data_images/24_01_13.RData")
}

#### Also mrege in protein names, desc, etc. from UniProt ####
df_up <- read.csv("uniprotkb_Human_AND_model_organism_9606_2024_10_21.tsv",header = T, na.strings = c(""), sep = "\t")
names(df_up)[which(names(df_up)=="Entry")] <- "Protein"
df_plot <- list_DA_msstats$ComparisonResult
df_plot <- merge(df_up, df_plot, by = "Protein", all.y = T)

```

## Exploring processed data

Starting with volcano plots.

```{r}

vec_comparisons <- unique(df_plot$Label)
df_plotme <- df_plot[which(df_plot$Label=="TRAF7_3nM-Control"), ]
ggplotly(ggplot(data = df_plotme, aes(x = log2FC, y = -log10(adj.pvalue), label = Gene.Names..primary.)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05))
)

df_linear <- df_plot[which(df_plot$Label=="TRAF7_3nM-Control" | df_plot$Label=="TRAF7_30nM-Control"), ]
df_linear2 <- reshape(df_linear, idvar = "Protein", timevar = "Label", direction = "wide")
ggplotly(
  ggplot(data = df_linear2, aes(x = `log2FC.TRAF7_3nM-Control`, y = `log2FC.TRAF7_30nM-Control`, label = `Gene.Names..primary..TRAF7_3nM-Control`)) +
    geom_point()
)
```

## Mary's Total Proteome

Want to see if any native complex members are dissociating with compound addition.

```{r}
```{r}

#### Read in data from PDP ####
## Data table to be passed from PDP
## PDP SOURCE
df_raw_from_PDP <- read.csv("KLF2_EA_PSMs_112624 (1).csv", header = T, na.strings = c("", "NA", "NaN", "NULL", "Null", "null", "na"))
## Change name of "File.ID" to "Spectrum.File"
# colnames(df_raw_from_PDP)[which(colnames(df_raw_from_PDP)=="File.ID")] <- "Spectrum.File"
## Assign a character that dictates where the sourced data is from, which dictates which converter to use. Options are "Spectronaut", "PD"
## PDP SOURCE
char_PDP_df_source <- "PD"

#### Filtering and X to MSstats Format Conversion, Annotation file ####
if (char_PDP_df_source == "PD") {
  ## Building df_annot manually
  ## Building the annotation file, df_annot, from PDP output "pools_export" file.
  # df_pools <- read.csv("dummy.tsv", header = T, sep = "\t", na.strings = c("", "NA", "NaN", "NULL", "Null", "null", "na"))
  # ## This is annotation df for TMT experiments 
  # ## Create the start of a df_annot df to fill
  # df_annot <- data.frame(
  #   ## sample_channel == Channel
  #   Channel = df_pools$sample_channel,
  #   ## treatment/drug == Condition, needs to be sorted out below
  #   Condition = rep(NA, length (df_pools$sample_channel)),
  #   ## BioReplicate == df$num <- ave(df$val, df$cat, FUN = seq_along) from Condition
  #   BioReplicate = rep(NA, length (df_pools$sample_channel)),
  #   ## Number of technical replicates. This will be accommodated in the future.
  #   TechRepMixture = rep(1, length(df_pools$sample_channel)),
  #   ## Fraction == matches number of Spectrum.File
  #   Fraction = rep(NA, length (df_pools$sample_channel)),
  #   ## Mixture, likely is 1. This would be multiple TMT mixtures. Another case for future.
  #   Mixture = rep(1, length (df_pools$sample_channel)),
  #   ## Run will be matched to Spectrum.File
  #   Run = rep(NA, length (df_pools$sample_channel))
  # )
  # ## Condition. For now, we can handle by drug/treatment columns
  # ## if there is a value in treatment, but not in drugs, use treatment column
  # df_annot$Condition <- ifelse(!is.na(df_pools$treatment) & is.na(df_pools$drug), df_pools$treatment, NA)
  # ## if there is a value in drugs, but not treatment, use drugs
  # df_annot$Condition <- ifelse(is.na(df_pools$treatment) & !is.na(df_pools$drug), df_pools$drug, df_annot$Condition)
  # ## all remaining conditions should concatenate
  # df_annot$Condition <- ifelse(is.na(df_annot$Condition), paste0(df_pools$treatment, ",",df_pools$drug), df_annot$Condition)
  # 
  # ## BioReplicate. We are assigning automatically based on "Condition", or "treatment" and "drug" from df_pools, but this can change if PDP has replicates entry.
  # df_annot$BioReplicate <- ave(df_annot$Channel, df_annot$Condition, FUN = seq_along)
  # ## repeat this the number of times * fractions/Spectrum.File
  # df_annot <- do.call("rbind", replicate(length(unique(df_raw_from_PDP$Spectrum.File)), df_annot, simplify = FALSE))
  # ## Fill in fraction number
  # df_annot$Fraction <- rep(c(1:length(unique(df_raw_from_PDP$Spectrum.File))), each = length(unique(df_annot$Channel)))
  # ## Add Spectrum.File for each fraction, in order
  # vec_spectrum_files <- unique(df_raw_from_PDP$Spectrum.File)
  # vec_spectrum_files <- vec_spectrum_files[order(nchar(vec_spectrum_files), vec_spectrum_files)]
  # df_annot$Run <- rep(vec_spectrum_files, each = length(unique(df_annot$Channel)))
  # ## save memory
  # df_annot_precursor <- NULL
  df_annot <- read.csv("PD_annot_manual_TP.csv", header = T, sep = ",")
  df_annot <- do.call("rbind", replicate(length(unique(df_raw_from_PDP$Spectrum.File)), df_annot, simplify = FALSE))
  df_annot$TechRepMixture <- 1
  df_annot$Fraction <- rep(c(1:length(unique(df_raw_from_PDP$Spectrum.File))), each = length(unique(df_annot$Channel)))
  vec_spectrum_files <- unique(df_raw_from_PDP$Spectrum.File)
  vec_spectrum_files <- vec_spectrum_files[order(nchar(vec_spectrum_files), vec_spectrum_files)]
  df_annot$Run <- rep(vec_spectrum_files, each = length(unique(df_annot$Channel)))
  df_annot$Condition <- gsub("-.*$", "", df_annot$Condition)
  
  ## Run the MSstats converter. "Master.Protein.Accessions" is used for "ProteinName". "Sequence" and "Modifications" are used for "PeptideSequence". "Charge"
  list_quant <- MSstatsTMT::PDtoMSstatsTMTFormat(input = df_raw_from_PDP, 
                                                 annotation = df_annot, 
                                                 use_log_file = FALSE)
  ## save memory
  df_raw_from_PDP <- NULL

  ## dataProcess step with the output from the converter
  list_MSstats_processed <- MSstatsTMT::proteinSummarization(list_quant,
                                                       method = "msstats",
                                                       global_norm = TRUE,
                                                       MBimpute = FALSE, 
                                                       use_log_file = FALSE)
  ## save memory, compost
  list_quant <- NULL
  ## need to hold onto the entire list_MSstats_processed for the groupComparison step later
  
  ## some PD TMT plots. Might be useful integration eventually.
  dataProcessPlotsTMT(data = list_MSstats_processed, type = "QCplot", which.Protein = "allonly", width = 21, height = 7)
  ## This is nice for peptide level analysis!
  dataProcessPlotsTMT(data = list_MSstats_processed, type = "ProfilePlot", which.Protein = 1, width = 21, height = 7)
}

if(char_PDP_df_source=="PD") {
  ## make the controls, aka denominator
  ## PDP SOURCE
  vec_control_conditions <- c("Control", "Control_probe")
  ## create a list to collapse at end of building, one matrix for each control condition
  ## each element of this list will become a matrix, which we will rbind together at end
  list_mat_comparison_msstats <- vector("list", length= length(vec_control_conditions))
  ## make the experimental conditions. These have to match what PDP assigns as vec_control_conditions, have to match what is in the dataset. For Spectronaut, this is R.Condition column. 
  vec_experimental_conditions <- levels(list_MSstats_processed$ProteinLevelData$Condition)[!(levels(list_MSstats_processed$ProteinLevelData$Condition) %in% vec_control_conditions)]
  ## how to automate this matrix, hmm
  
  ## First create matrices that are length(vec_experimental_conditions) rows long with rownames == vec_experimental_conditions and colnames == all.
  for (i in 1:length(list_mat_comparison_msstats)) {
    ## for now, the rownames do not contain the name of the control condition. We will replace later after grepl step. 
    list_mat_comparison_msstats_names01 <- list(mat_comparison_rows = paste0(vec_experimental_conditions),
                                                mat_comparison_cols = levels(list_MSstats_processed$ProteinLevelData$Condition))
    list_mat_comparison_msstats[[i]] <- matrix(ncol = length(levels(list_MSstats_processed$ProteinLevelData$Condition)),
                                               nrow = length(vec_experimental_conditions),
                                               dimnames = list_mat_comparison_msstats_names01)
  }
  
  ## This is the major matrix creation step
  for (j in 1:length(list_mat_comparison_msstats)) {
    for (i in 1:length(vec_experimental_conditions)) {
      a <- paste0("^", vec_experimental_conditions[i], "$")
      b <- list_mat_comparison_msstats[[j]][i,]
      list_mat_comparison_msstats[[j]][i,] <- as.integer(grepl(a, names(b)))
    }
  }
  
  ## Now that we have that, we can assign the controls a value of -1
  for (i in 1:length(vec_control_conditions)) {
    list_mat_comparison_msstats[[i]][,grep(paste0("^", vec_control_conditions[i], "$"), colnames(list_mat_comparison_msstats[[i]]))] <- -1
  }
  
  ## last step is to add the control to the rownames
  for (i in 1:length(list_mat_comparison_msstats)) {
    list_mat_comparison_msstats_names02 <- paste0(vec_experimental_conditions, "-", vec_control_conditions[i])
    rownames(list_mat_comparison_msstats[[i]]) <-  list_mat_comparison_msstats_names02
    
  }
  
  ## Collapse into comparison matrix
  mat_comparison_msstats <- do.call(rbind, list_mat_comparison_msstats)
  ## BOOM
}

#### Run groupComparison, the stats portion, of MSstats ####
## Run the differential analysis using MSstats
list_DA_msstats <- MSstatsTMT::groupComparisonTMT(contrast.matrix = mat_comparison_msstats, data = list_MSstats_processed)

if(!file.exists("./data_images/24_01_13_TP.RData")) {
  save.image("./data_images/24_01_13_TP.RData")
}

#### Also mrege in protein names, desc, etc. from UniProt ####
df_up <- read.csv("uniprotkb_Human_AND_model_organism_9606_2024_10_21.tsv",header = T, na.strings = c(""), sep = "\t")
names(df_up)[which(names(df_up)=="Entry")] <- "Protein"
df_plot <- list_DA_msstats$ComparisonResult
df_plot <- merge(df_up, df_plot, by = "Protein", all.y = T)
```

Plot Mary's TP results.

```{r}
df_plotme <- df_plot[which(df_plot$Label=="C750-Control"), ]
ggplotly(ggplot(data = df_plotme, aes(x = log2FC, y = -log10(adj.pvalue), label = Gene.Names..primary.)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05))
)
```

